# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rexml` gem.
# Please instead update this file by running `bin/tapioca gem rexml`.


# source://rexml//lib/rexml/encoding.rb#4
module REXML::Encoding
  # source://rexml//lib/rexml/encoding.rb#29
  def decode(string); end

  # source://rexml//lib/rexml/encoding.rb#25
  def encode(string); end

  # ID ---> Encoding name
  #
  # source://rexml//lib/rexml/encoding.rb#6
  def encoding; end

  # source://rexml//lib/rexml/encoding.rb#7
  def encoding=(encoding); end

  private

  # source://rexml//lib/rexml/encoding.rb#34
  def find_encoding(name); end
end

# A Source that wraps an IO.  See the Source class for method
# documentation
#
# source://rexml//lib/rexml/source.rb#176
class REXML::IOSource < ::REXML::Source
  # block_size has been deprecated
  #
  # @return [IOSource] a new instance of IOSource
  #
  # source://rexml//lib/rexml/source.rb#180
  def initialize(arg, block_size = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#258
  def current_line; end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#253
  def empty?; end

  # source://rexml//lib/rexml/source.rb#230
  def ensure_buffer; end

  # Note: When specifying a string for 'pattern', it must not include '>' except in the following formats:
  # - ">"
  # - "XXX>" (X is any string excluding '>')
  #
  # source://rexml//lib/rexml/source.rb#237
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#201
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#212
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#300
  def encoding_updated; end

  # source://rexml//lib/rexml/source.rb#280
  def readline(term = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/parseexception.rb#3
class REXML::ParseException < ::RuntimeError
  # @return [ParseException] a new instance of ParseException
  #
  # source://rexml//lib/rexml/parseexception.rb#6
  def initialize(message, source = T.unsafe(nil), parser = T.unsafe(nil), exception = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parseexception.rb#49
  def context; end

  # Returns the value of attribute continued_exception.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception; end

  # Sets the attribute continued_exception
  #
  # @param value the value to set the attribute continued_exception to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#44
  def line; end

  # Returns the value of attribute parser.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser; end

  # Sets the attribute parser
  #
  # @param value the value to set the attribute parser to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#39
  def position; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#13
  def to_s; end
end

# = Using the Pull Parser
# <em>This API is experimental, and subject to change.</em>
#  parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
#  while parser.has_next?
#    res = parser.next
#    puts res[1]['att'] if res.start_tag? and res[0] == 'b'
#  end
# See the PullEvent class for information on the content of the results.
# The data is identical to the arguments passed for the various events to
# the StreamListener API.
#
# Notice that:
#  parser = PullParser.new( "<a>BAD DOCUMENT" )
#  while parser.has_next?
#    res = parser.next
#    raise res[1] if res.error?
#  end
#
# Nat Price gave me some good ideas for the API.
#
# source://rexml//lib/rexml/parsers/baseparser.rb#40
class REXML::Parsers::BaseParser
  include ::REXML::Parsers::BaseParser::Private

  # @return [BaseParser] a new instance of BaseParser
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#139
  def initialize(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#144
  def add_listener(listener); end

  # Returns true if there are no more events
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#170
  def empty?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#463
  def entity(reference, entities); end

  # Returns true if there are more events.  Synonymous with !empty?
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#175
  def has_next?; end

  # Escapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#474
  def normalize(input, entities = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

  # Peek at the +depth+ event in the stack.  The first element on the stack
  # is at depth 0.  If +depth+ is -1, will parse to the end of the input
  # stream and return the last event, which is always :end_document.
  # Be aware that this causes the stream to be parsed up to the +depth+
  # event, so you can effectively pre-parse the entire document (pull the
  # entire thing into memory) using this method.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#191
  def peek(depth = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#160
  def position; end

  # Returns the next event.  This is a +PullEvent+ object.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#206
  def pull; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#148
  def source; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#150
  def stream=(source); end

  # Unescapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#490
  def unnormalize(string, entities = T.unsafe(nil), filter = T.unsafe(nil)); end

  # Push an event back on the head of the stream.  This method
  # has (theoretically) infinite depth.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#181
  def unshift(token); end

  private

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#519
  def need_source_encoding_update?(xml_declaration_encoding); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#630
  def parse_attributes(prefixes, curr_ns); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#538
  def parse_id(base_error_message, accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#566
  def parse_id_invalid_details(accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#525
  def parse_name(base_error_message); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#604
  def process_instruction(start_position); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#214
  def pull_event; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#113
REXML::Parsers::BaseParser::EXTERNAL_ID_PUBLIC = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#114
REXML::Parsers::BaseParser::EXTERNAL_ID_SYSTEM = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#115
REXML::Parsers::BaseParser::PUBLIC_ID = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#126
module REXML::Parsers::BaseParser::Private; end

# source://rexml//lib/rexml/parsers/baseparser.rb#130
REXML::Parsers::BaseParser::Private::ATTLISTDECL_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#129
REXML::Parsers::BaseParser::Private::CLOSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#134
REXML::Parsers::BaseParser::Private::ENTITYDECL_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#132
REXML::Parsers::BaseParser::Private::GEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#127
REXML::Parsers::BaseParser::Private::INSTRUCTION_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#131
REXML::Parsers::BaseParser::Private::NAME_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#133
REXML::Parsers::BaseParser::Private::PEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#128
REXML::Parsers::BaseParser::Private::TAG_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#49
REXML::Parsers::BaseParser::QNAME = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#48
REXML::Parsers::BaseParser::QNAME_STR = T.let(T.unsafe(nil), String)

# A Source can be searched for patterns, and wraps buffers and other
# objects and provides consumption of text
#
# source://rexml//lib/rexml/source.rb#51
class REXML::Source
  include ::REXML::Encoding
  include ::REXML::Source::Private

  # Constructor
  # value, overriding all encoding detection
  #
  # @param arg must be a String, and should be a valid XML document
  # @param encoding if non-null, sets the encoding of the source to this
  # @return [Source] a new instance of Source
  #
  # source://rexml//lib/rexml/source.rb#71
  def initialize(arg, encoding = T.unsafe(nil)); end

  # The current buffer (what we're going to read next)
  #
  # source://rexml//lib/rexml/source.rb#83
  def buffer; end

  # source://rexml//lib/rexml/source.rb#87
  def buffer_encoding=(encoding); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#136
  def current_line; end

  # @return [Boolean] true if the Source is exhausted
  #
  # source://rexml//lib/rexml/source.rb#131
  def empty?; end

  # Returns the value of attribute encoding.
  #
  # source://rexml//lib/rexml/source.rb#55
  def encoding; end

  # Inherited from Encoding
  # Overridden to support optimized en/decoding
  #
  # source://rexml//lib/rexml/source.rb#93
  def encoding=(enc); end

  # source://rexml//lib/rexml/source.rb#111
  def ensure_buffer; end

  # The line number of the last consumed text
  #
  # source://rexml//lib/rexml/source.rb#54
  def line; end

  # source://rexml//lib/rexml/source.rb#114
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#122
  def position; end

  # source://rexml//lib/rexml/source.rb#126
  def position=(pos); end

  # source://rexml//lib/rexml/source.rb#98
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#101
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#145
  def detect_encoding; end

  # source://rexml//lib/rexml/source.rb#163
  def encoding_updated; end
end

# source://rexml//lib/rexml/source.rb#57
module REXML::Source::Private; end

# source://rexml//lib/rexml/source.rb#58
REXML::Source::Private::PRE_DEFINED_TERM_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://rexml//lib/rexml/undefinednamespaceexception.rb#4
class REXML::UndefinedNamespaceException < ::REXML::ParseException
  # @return [UndefinedNamespaceException] a new instance of UndefinedNamespaceException
  #
  # source://rexml//lib/rexml/undefinednamespaceexception.rb#5
  def initialize(prefix, source, parser); end
end
